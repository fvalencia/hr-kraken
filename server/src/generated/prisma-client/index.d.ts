// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  application: (where?: ApplicationWhereInput) => Promise<boolean>;
  applicationStep: (where?: ApplicationStepWhereInput) => Promise<boolean>;
  candidate: (where?: CandidateWhereInput) => Promise<boolean>;
  opening: (where?: OpeningWhereInput) => Promise<boolean>;
  step: (where?: StepWhereInput) => Promise<boolean>;
  templateStep: (where?: TemplateStepWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  application: (
    where: ApplicationWhereUniqueInput
  ) => ApplicationNullablePromise;
  applications: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Application>;
  applicationsConnection: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplicationConnectionPromise;
  applicationStep: (
    where: ApplicationStepWhereUniqueInput
  ) => ApplicationStepNullablePromise;
  applicationSteps: (args?: {
    where?: ApplicationStepWhereInput;
    orderBy?: ApplicationStepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ApplicationStep>;
  applicationStepsConnection: (args?: {
    where?: ApplicationStepWhereInput;
    orderBy?: ApplicationStepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplicationStepConnectionPromise;
  candidate: (where: CandidateWhereUniqueInput) => CandidateNullablePromise;
  candidates: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Candidate>;
  candidatesConnection: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CandidateConnectionPromise;
  opening: (where: OpeningWhereUniqueInput) => OpeningNullablePromise;
  openings: (args?: {
    where?: OpeningWhereInput;
    orderBy?: OpeningOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Opening>;
  openingsConnection: (args?: {
    where?: OpeningWhereInput;
    orderBy?: OpeningOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OpeningConnectionPromise;
  step: (where: StepWhereUniqueInput) => StepNullablePromise;
  steps: (args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Step>;
  stepsConnection: (args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StepConnectionPromise;
  templateStep: (
    where: TemplateStepWhereUniqueInput
  ) => TemplateStepNullablePromise;
  templateSteps: (args?: {
    where?: TemplateStepWhereInput;
    orderBy?: TemplateStepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TemplateStep>;
  templateStepsConnection: (args?: {
    where?: TemplateStepWhereInput;
    orderBy?: TemplateStepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TemplateStepConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApplication: (data: ApplicationCreateInput) => ApplicationPromise;
  updateApplication: (args: {
    data: ApplicationUpdateInput;
    where: ApplicationWhereUniqueInput;
  }) => ApplicationPromise;
  updateManyApplications: (args: {
    data: ApplicationUpdateManyMutationInput;
    where?: ApplicationWhereInput;
  }) => BatchPayloadPromise;
  upsertApplication: (args: {
    where: ApplicationWhereUniqueInput;
    create: ApplicationCreateInput;
    update: ApplicationUpdateInput;
  }) => ApplicationPromise;
  deleteApplication: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  deleteManyApplications: (
    where?: ApplicationWhereInput
  ) => BatchPayloadPromise;
  createApplicationStep: (
    data: ApplicationStepCreateInput
  ) => ApplicationStepPromise;
  updateApplicationStep: (args: {
    data: ApplicationStepUpdateInput;
    where: ApplicationStepWhereUniqueInput;
  }) => ApplicationStepPromise;
  updateManyApplicationSteps: (args: {
    data: ApplicationStepUpdateManyMutationInput;
    where?: ApplicationStepWhereInput;
  }) => BatchPayloadPromise;
  upsertApplicationStep: (args: {
    where: ApplicationStepWhereUniqueInput;
    create: ApplicationStepCreateInput;
    update: ApplicationStepUpdateInput;
  }) => ApplicationStepPromise;
  deleteApplicationStep: (
    where: ApplicationStepWhereUniqueInput
  ) => ApplicationStepPromise;
  deleteManyApplicationSteps: (
    where?: ApplicationStepWhereInput
  ) => BatchPayloadPromise;
  createCandidate: (data: CandidateCreateInput) => CandidatePromise;
  updateCandidate: (args: {
    data: CandidateUpdateInput;
    where: CandidateWhereUniqueInput;
  }) => CandidatePromise;
  updateManyCandidates: (args: {
    data: CandidateUpdateManyMutationInput;
    where?: CandidateWhereInput;
  }) => BatchPayloadPromise;
  upsertCandidate: (args: {
    where: CandidateWhereUniqueInput;
    create: CandidateCreateInput;
    update: CandidateUpdateInput;
  }) => CandidatePromise;
  deleteCandidate: (where: CandidateWhereUniqueInput) => CandidatePromise;
  deleteManyCandidates: (where?: CandidateWhereInput) => BatchPayloadPromise;
  createOpening: (data: OpeningCreateInput) => OpeningPromise;
  updateOpening: (args: {
    data: OpeningUpdateInput;
    where: OpeningWhereUniqueInput;
  }) => OpeningPromise;
  updateManyOpenings: (args: {
    data: OpeningUpdateManyMutationInput;
    where?: OpeningWhereInput;
  }) => BatchPayloadPromise;
  upsertOpening: (args: {
    where: OpeningWhereUniqueInput;
    create: OpeningCreateInput;
    update: OpeningUpdateInput;
  }) => OpeningPromise;
  deleteOpening: (where: OpeningWhereUniqueInput) => OpeningPromise;
  deleteManyOpenings: (where?: OpeningWhereInput) => BatchPayloadPromise;
  createStep: (data: StepCreateInput) => StepPromise;
  updateStep: (args: {
    data: StepUpdateInput;
    where: StepWhereUniqueInput;
  }) => StepPromise;
  updateManySteps: (args: {
    data: StepUpdateManyMutationInput;
    where?: StepWhereInput;
  }) => BatchPayloadPromise;
  upsertStep: (args: {
    where: StepWhereUniqueInput;
    create: StepCreateInput;
    update: StepUpdateInput;
  }) => StepPromise;
  deleteStep: (where: StepWhereUniqueInput) => StepPromise;
  deleteManySteps: (where?: StepWhereInput) => BatchPayloadPromise;
  createTemplateStep: (data: TemplateStepCreateInput) => TemplateStepPromise;
  updateTemplateStep: (args: {
    data: TemplateStepUpdateInput;
    where: TemplateStepWhereUniqueInput;
  }) => TemplateStepPromise;
  updateManyTemplateSteps: (args: {
    data: TemplateStepUpdateManyMutationInput;
    where?: TemplateStepWhereInput;
  }) => BatchPayloadPromise;
  upsertTemplateStep: (args: {
    where: TemplateStepWhereUniqueInput;
    create: TemplateStepCreateInput;
    update: TemplateStepUpdateInput;
  }) => TemplateStepPromise;
  deleteTemplateStep: (
    where: TemplateStepWhereUniqueInput
  ) => TemplateStepPromise;
  deleteManyTemplateSteps: (
    where?: TemplateStepWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  application: (
    where?: ApplicationSubscriptionWhereInput
  ) => ApplicationSubscriptionPayloadSubscription;
  applicationStep: (
    where?: ApplicationStepSubscriptionWhereInput
  ) => ApplicationStepSubscriptionPayloadSubscription;
  candidate: (
    where?: CandidateSubscriptionWhereInput
  ) => CandidateSubscriptionPayloadSubscription;
  opening: (
    where?: OpeningSubscriptionWhereInput
  ) => OpeningSubscriptionPayloadSubscription;
  step: (
    where?: StepSubscriptionWhereInput
  ) => StepSubscriptionPayloadSubscription;
  templateStep: (
    where?: TemplateStepSubscriptionWhereInput
  ) => TemplateStepSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ApplicationStepOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "feedback_ASC"
  | "feedback_DESC"
  | "completionDate_ASC"
  | "completionDate_DESC"
  | "result_ASC"
  | "result_DESC"
  | "responsable_ASC"
  | "responsable_DESC";

export type Status =
  | "AVAILABLE"
  | "IN_PROGRESS"
  | "HIRED"
  | "QUIT_PROCESS"
  | "REJECTED";

export type Seniority = "JUNIOR" | "MIDDLE" | "SENIOR";

export type OpeningStatus = "OPEN" | "CLOSED";

export type ApplicationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "feedback_ASC"
  | "feedback_DESC"
  | "responsable_ASC"
  | "responsable_DESC"
  | "result_ASC"
  | "result_DESC";

export type StepOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CandidateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "title_ASC"
  | "title_DESC"
  | "email_ASC"
  | "email_DESC"
  | "yearsOfExperience_ASC"
  | "yearsOfExperience_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "skypeId_ASC"
  | "skypeId_DESC"
  | "salaryExpectation_ASC"
  | "salaryExpectation_DESC"
  | "cv_ASC"
  | "cv_DESC"
  | "seniority_ASC"
  | "seniority_DESC"
  | "status_ASC"
  | "status_DESC";

export type Result = "BAD" | "AVERAGE" | "GOOD" | "EXCELENT";

export type OpeningOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "jobTitle_ASC"
  | "jobTitle_DESC"
  | "jobDescription_ASC"
  | "jobDescription_DESC"
  | "company_ASC"
  | "company_DESC"
  | "maxSalaryRange_ASC"
  | "maxSalaryRange_DESC"
  | "status_ASC"
  | "status_DESC";

export type TemplateStepOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC";

export interface StepUpdateWithWhereUniqueNestedInput {
  where: StepWhereUniqueInput;
  data: StepUpdateDataInput;
}

export type ApplicationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ApplicationStepUpdateManyWithoutApplicationInput {
  create?: Maybe<
    | ApplicationStepCreateWithoutApplicationInput[]
    | ApplicationStepCreateWithoutApplicationInput
  >;
  delete?: Maybe<
    ApplicationStepWhereUniqueInput[] | ApplicationStepWhereUniqueInput
  >;
  connect?: Maybe<
    ApplicationStepWhereUniqueInput[] | ApplicationStepWhereUniqueInput
  >;
  set?: Maybe<
    ApplicationStepWhereUniqueInput[] | ApplicationStepWhereUniqueInput
  >;
  disconnect?: Maybe<
    ApplicationStepWhereUniqueInput[] | ApplicationStepWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationStepUpdateWithWhereUniqueWithoutApplicationInput[]
    | ApplicationStepUpdateWithWhereUniqueWithoutApplicationInput
  >;
  upsert?: Maybe<
    | ApplicationStepUpsertWithWhereUniqueWithoutApplicationInput[]
    | ApplicationStepUpsertWithWhereUniqueWithoutApplicationInput
  >;
  deleteMany?: Maybe<
    ApplicationStepScalarWhereInput[] | ApplicationStepScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationStepUpdateManyWithWhereNestedInput[]
    | ApplicationStepUpdateManyWithWhereNestedInput
  >;
}

export interface OpeningWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  jobTitle?: Maybe<String>;
  jobTitle_not?: Maybe<String>;
  jobTitle_in?: Maybe<String[] | String>;
  jobTitle_not_in?: Maybe<String[] | String>;
  jobTitle_lt?: Maybe<String>;
  jobTitle_lte?: Maybe<String>;
  jobTitle_gt?: Maybe<String>;
  jobTitle_gte?: Maybe<String>;
  jobTitle_contains?: Maybe<String>;
  jobTitle_not_contains?: Maybe<String>;
  jobTitle_starts_with?: Maybe<String>;
  jobTitle_not_starts_with?: Maybe<String>;
  jobTitle_ends_with?: Maybe<String>;
  jobTitle_not_ends_with?: Maybe<String>;
  jobDescription?: Maybe<String>;
  jobDescription_not?: Maybe<String>;
  jobDescription_in?: Maybe<String[] | String>;
  jobDescription_not_in?: Maybe<String[] | String>;
  jobDescription_lt?: Maybe<String>;
  jobDescription_lte?: Maybe<String>;
  jobDescription_gt?: Maybe<String>;
  jobDescription_gte?: Maybe<String>;
  jobDescription_contains?: Maybe<String>;
  jobDescription_not_contains?: Maybe<String>;
  jobDescription_starts_with?: Maybe<String>;
  jobDescription_not_starts_with?: Maybe<String>;
  jobDescription_ends_with?: Maybe<String>;
  jobDescription_not_ends_with?: Maybe<String>;
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  maxSalaryRange?: Maybe<Float>;
  maxSalaryRange_not?: Maybe<Float>;
  maxSalaryRange_in?: Maybe<Float[] | Float>;
  maxSalaryRange_not_in?: Maybe<Float[] | Float>;
  maxSalaryRange_lt?: Maybe<Float>;
  maxSalaryRange_lte?: Maybe<Float>;
  maxSalaryRange_gt?: Maybe<Float>;
  maxSalaryRange_gte?: Maybe<Float>;
  steps_every?: Maybe<StepWhereInput>;
  steps_some?: Maybe<StepWhereInput>;
  steps_none?: Maybe<StepWhereInput>;
  applications_every?: Maybe<ApplicationWhereInput>;
  applications_some?: Maybe<ApplicationWhereInput>;
  applications_none?: Maybe<ApplicationWhereInput>;
  status?: Maybe<OpeningStatus>;
  status_not?: Maybe<OpeningStatus>;
  status_in?: Maybe<OpeningStatus[] | OpeningStatus>;
  status_not_in?: Maybe<OpeningStatus[] | OpeningStatus>;
  AND?: Maybe<OpeningWhereInput[] | OpeningWhereInput>;
  OR?: Maybe<OpeningWhereInput[] | OpeningWhereInput>;
  NOT?: Maybe<OpeningWhereInput[] | OpeningWhereInput>;
}

export interface ApplicationStepUpdateWithWhereUniqueWithoutApplicationInput {
  where: ApplicationStepWhereUniqueInput;
  data: ApplicationStepUpdateWithoutApplicationDataInput;
}

export interface CandidateWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  yearsOfExperience?: Maybe<Int>;
  yearsOfExperience_not?: Maybe<Int>;
  yearsOfExperience_in?: Maybe<Int[] | Int>;
  yearsOfExperience_not_in?: Maybe<Int[] | Int>;
  yearsOfExperience_lt?: Maybe<Int>;
  yearsOfExperience_lte?: Maybe<Int>;
  yearsOfExperience_gt?: Maybe<Int>;
  yearsOfExperience_gte?: Maybe<Int>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  skypeId?: Maybe<String>;
  skypeId_not?: Maybe<String>;
  skypeId_in?: Maybe<String[] | String>;
  skypeId_not_in?: Maybe<String[] | String>;
  skypeId_lt?: Maybe<String>;
  skypeId_lte?: Maybe<String>;
  skypeId_gt?: Maybe<String>;
  skypeId_gte?: Maybe<String>;
  skypeId_contains?: Maybe<String>;
  skypeId_not_contains?: Maybe<String>;
  skypeId_starts_with?: Maybe<String>;
  skypeId_not_starts_with?: Maybe<String>;
  skypeId_ends_with?: Maybe<String>;
  skypeId_not_ends_with?: Maybe<String>;
  salaryExpectation?: Maybe<Float>;
  salaryExpectation_not?: Maybe<Float>;
  salaryExpectation_in?: Maybe<Float[] | Float>;
  salaryExpectation_not_in?: Maybe<Float[] | Float>;
  salaryExpectation_lt?: Maybe<Float>;
  salaryExpectation_lte?: Maybe<Float>;
  salaryExpectation_gt?: Maybe<Float>;
  salaryExpectation_gte?: Maybe<Float>;
  cv?: Maybe<String>;
  cv_not?: Maybe<String>;
  cv_in?: Maybe<String[] | String>;
  cv_not_in?: Maybe<String[] | String>;
  cv_lt?: Maybe<String>;
  cv_lte?: Maybe<String>;
  cv_gt?: Maybe<String>;
  cv_gte?: Maybe<String>;
  cv_contains?: Maybe<String>;
  cv_not_contains?: Maybe<String>;
  cv_starts_with?: Maybe<String>;
  cv_not_starts_with?: Maybe<String>;
  cv_ends_with?: Maybe<String>;
  cv_not_ends_with?: Maybe<String>;
  applications_every?: Maybe<ApplicationWhereInput>;
  applications_some?: Maybe<ApplicationWhereInput>;
  applications_none?: Maybe<ApplicationWhereInput>;
  seniority?: Maybe<Seniority>;
  seniority_not?: Maybe<Seniority>;
  seniority_in?: Maybe<Seniority[] | Seniority>;
  seniority_not_in?: Maybe<Seniority[] | Seniority>;
  status?: Maybe<Status>;
  status_not?: Maybe<Status>;
  status_in?: Maybe<Status[] | Status>;
  status_not_in?: Maybe<Status[] | Status>;
  AND?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
  OR?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
  NOT?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
}

export interface ApplicationStepUpdateWithoutApplicationDataInput {
  step?: Maybe<StepUpdateOneRequiredInput>;
  feedback?: Maybe<String>;
  completionDate?: Maybe<DateTimeInput>;
  result?: Maybe<Result>;
  responsable?: Maybe<String>;
}

export interface ApplicationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  feedback_not?: Maybe<String>;
  feedback_in?: Maybe<String[] | String>;
  feedback_not_in?: Maybe<String[] | String>;
  feedback_lt?: Maybe<String>;
  feedback_lte?: Maybe<String>;
  feedback_gt?: Maybe<String>;
  feedback_gte?: Maybe<String>;
  feedback_contains?: Maybe<String>;
  feedback_not_contains?: Maybe<String>;
  feedback_starts_with?: Maybe<String>;
  feedback_not_starts_with?: Maybe<String>;
  feedback_ends_with?: Maybe<String>;
  feedback_not_ends_with?: Maybe<String>;
  responsable?: Maybe<String>;
  responsable_not?: Maybe<String>;
  responsable_in?: Maybe<String[] | String>;
  responsable_not_in?: Maybe<String[] | String>;
  responsable_lt?: Maybe<String>;
  responsable_lte?: Maybe<String>;
  responsable_gt?: Maybe<String>;
  responsable_gte?: Maybe<String>;
  responsable_contains?: Maybe<String>;
  responsable_not_contains?: Maybe<String>;
  responsable_starts_with?: Maybe<String>;
  responsable_not_starts_with?: Maybe<String>;
  responsable_ends_with?: Maybe<String>;
  responsable_not_ends_with?: Maybe<String>;
  result?: Maybe<Result>;
  result_not?: Maybe<Result>;
  result_in?: Maybe<Result[] | Result>;
  result_not_in?: Maybe<Result[] | Result>;
  candidate?: Maybe<CandidateWhereInput>;
  opening?: Maybe<OpeningWhereInput>;
  steps_every?: Maybe<ApplicationStepWhereInput>;
  steps_some?: Maybe<ApplicationStepWhereInput>;
  steps_none?: Maybe<ApplicationStepWhereInput>;
  AND?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  OR?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  NOT?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
}

export interface StepCreateManyInput {
  create?: Maybe<StepCreateInput[] | StepCreateInput>;
  connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
}

export interface CandidateCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  title: String;
  email: String;
  yearsOfExperience?: Maybe<Int>;
  phone?: Maybe<String>;
  skypeId?: Maybe<String>;
  salaryExpectation?: Maybe<Float>;
  cv?: Maybe<String>;
  applications?: Maybe<ApplicationCreateManyWithoutCandidateInput>;
  seniority: Seniority;
  status: Status;
}

export interface StepCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface StepUpdateOneRequiredInput {
  create?: Maybe<StepCreateInput>;
  update?: Maybe<StepUpdateDataInput>;
  upsert?: Maybe<StepUpsertNestedInput>;
  connect?: Maybe<StepWhereUniqueInput>;
}

export interface ApplicationStepCreateManyWithoutApplicationInput {
  create?: Maybe<
    | ApplicationStepCreateWithoutApplicationInput[]
    | ApplicationStepCreateWithoutApplicationInput
  >;
  connect?: Maybe<
    ApplicationStepWhereUniqueInput[] | ApplicationStepWhereUniqueInput
  >;
}

export interface StepSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StepWhereInput>;
  AND?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>;
  OR?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>;
  NOT?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>;
}

export interface ApplicationStepCreateWithoutApplicationInput {
  id?: Maybe<ID_Input>;
  step: StepCreateOneInput;
  feedback?: Maybe<String>;
  completionDate?: Maybe<DateTimeInput>;
  result?: Maybe<Result>;
  responsable?: Maybe<String>;
}

export interface CandidateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CandidateWhereInput>;
  AND?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
  OR?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
}

export interface StepCreateOneInput {
  create?: Maybe<StepCreateInput>;
  connect?: Maybe<StepWhereUniqueInput>;
}

export interface ApplicationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplicationWhereInput>;
  AND?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
}

export interface ApplicationUpdateInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutApplicationsInput>;
  opening?: Maybe<OpeningUpdateOneRequiredWithoutApplicationsInput>;
  steps?: Maybe<ApplicationStepUpdateManyWithoutApplicationInput>;
}

export type ApplicationStepWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CandidateUpdateOneRequiredWithoutApplicationsInput {
  create?: Maybe<CandidateCreateWithoutApplicationsInput>;
  update?: Maybe<CandidateUpdateWithoutApplicationsDataInput>;
  upsert?: Maybe<CandidateUpsertWithoutApplicationsInput>;
  connect?: Maybe<CandidateWhereUniqueInput>;
}

export interface TemplateStepCreateInput {
  steps?: Maybe<StepCreateManyInput>;
  name?: Maybe<String>;
  id?: Maybe<ID_Input>;
}

export interface CandidateUpdateWithoutApplicationsDataInput {
  name?: Maybe<String>;
  title?: Maybe<String>;
  email?: Maybe<String>;
  yearsOfExperience?: Maybe<Int>;
  phone?: Maybe<String>;
  skypeId?: Maybe<String>;
  salaryExpectation?: Maybe<Float>;
  cv?: Maybe<String>;
  seniority?: Maybe<Seniority>;
  status?: Maybe<Status>;
}

export type CandidateWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CandidateUpsertWithoutApplicationsInput {
  update: CandidateUpdateWithoutApplicationsDataInput;
  create: CandidateCreateWithoutApplicationsInput;
}

export interface OpeningUpdateManyMutationInput {
  jobTitle?: Maybe<String>;
  jobDescription?: Maybe<String>;
  company?: Maybe<String>;
  maxSalaryRange?: Maybe<Float>;
  status?: Maybe<OpeningStatus>;
}

export interface OpeningUpdateOneRequiredWithoutApplicationsInput {
  create?: Maybe<OpeningCreateWithoutApplicationsInput>;
  update?: Maybe<OpeningUpdateWithoutApplicationsDataInput>;
  upsert?: Maybe<OpeningUpsertWithoutApplicationsInput>;
  connect?: Maybe<OpeningWhereUniqueInput>;
}

export interface ApplicationUpdateWithoutOpeningDataInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutApplicationsInput>;
  steps?: Maybe<ApplicationStepUpdateManyWithoutApplicationInput>;
}

export interface OpeningUpdateWithoutApplicationsDataInput {
  jobTitle?: Maybe<String>;
  jobDescription?: Maybe<String>;
  company?: Maybe<String>;
  maxSalaryRange?: Maybe<Float>;
  steps?: Maybe<StepUpdateManyInput>;
  status?: Maybe<OpeningStatus>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutOpeningInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutOpeningDataInput;
}

export interface StepUpdateManyInput {
  create?: Maybe<StepCreateInput[] | StepCreateInput>;
  update?: Maybe<
    | StepUpdateWithWhereUniqueNestedInput[]
    | StepUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | StepUpsertWithWhereUniqueNestedInput[]
    | StepUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
  connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
  set?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
  disconnect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
  deleteMany?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>;
  updateMany?: Maybe<
    StepUpdateManyWithWhereNestedInput[] | StepUpdateManyWithWhereNestedInput
  >;
}

export interface OpeningUpdateInput {
  jobTitle?: Maybe<String>;
  jobDescription?: Maybe<String>;
  company?: Maybe<String>;
  maxSalaryRange?: Maybe<Float>;
  steps?: Maybe<StepUpdateManyInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutOpeningInput>;
  status?: Maybe<OpeningStatus>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutCandidateInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutCandidateDataInput;
}

export type StepWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StepUpdateDataInput {
  name?: Maybe<String>;
}

export interface OpeningCreateInput {
  id?: Maybe<ID_Input>;
  jobTitle: String;
  jobDescription: String;
  company?: Maybe<String>;
  maxSalaryRange?: Maybe<Float>;
  steps?: Maybe<StepCreateManyInput>;
  applications?: Maybe<ApplicationCreateManyWithoutOpeningInput>;
  status?: Maybe<OpeningStatus>;
}

export interface StepUpsertWithWhereUniqueNestedInput {
  where: StepWhereUniqueInput;
  update: StepUpdateDataInput;
  create: StepCreateInput;
}

export type TemplateStepWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StepScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>;
  OR?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>;
  NOT?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>;
}

export interface TemplateStepWhereInput {
  steps_every?: Maybe<StepWhereInput>;
  steps_some?: Maybe<StepWhereInput>;
  steps_none?: Maybe<StepWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<TemplateStepWhereInput[] | TemplateStepWhereInput>;
  OR?: Maybe<TemplateStepWhereInput[] | TemplateStepWhereInput>;
  NOT?: Maybe<TemplateStepWhereInput[] | TemplateStepWhereInput>;
}

export interface StepUpdateManyWithWhereNestedInput {
  where: StepScalarWhereInput;
  data: StepUpdateManyDataInput;
}

export interface ApplicationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  feedback_not?: Maybe<String>;
  feedback_in?: Maybe<String[] | String>;
  feedback_not_in?: Maybe<String[] | String>;
  feedback_lt?: Maybe<String>;
  feedback_lte?: Maybe<String>;
  feedback_gt?: Maybe<String>;
  feedback_gte?: Maybe<String>;
  feedback_contains?: Maybe<String>;
  feedback_not_contains?: Maybe<String>;
  feedback_starts_with?: Maybe<String>;
  feedback_not_starts_with?: Maybe<String>;
  feedback_ends_with?: Maybe<String>;
  feedback_not_ends_with?: Maybe<String>;
  responsable?: Maybe<String>;
  responsable_not?: Maybe<String>;
  responsable_in?: Maybe<String[] | String>;
  responsable_not_in?: Maybe<String[] | String>;
  responsable_lt?: Maybe<String>;
  responsable_lte?: Maybe<String>;
  responsable_gt?: Maybe<String>;
  responsable_gte?: Maybe<String>;
  responsable_contains?: Maybe<String>;
  responsable_not_contains?: Maybe<String>;
  responsable_starts_with?: Maybe<String>;
  responsable_not_starts_with?: Maybe<String>;
  responsable_ends_with?: Maybe<String>;
  responsable_not_ends_with?: Maybe<String>;
  result?: Maybe<Result>;
  result_not?: Maybe<Result>;
  result_in?: Maybe<Result[] | Result>;
  result_not_in?: Maybe<Result[] | Result>;
  AND?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  OR?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  NOT?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
}

export interface StepUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ApplicationUpdateWithoutCandidateDataInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
  opening?: Maybe<OpeningUpdateOneRequiredWithoutApplicationsInput>;
  steps?: Maybe<ApplicationStepUpdateManyWithoutApplicationInput>;
}

export interface OpeningUpsertWithoutApplicationsInput {
  update: OpeningUpdateWithoutApplicationsDataInput;
  create: OpeningCreateWithoutApplicationsInput;
}

export interface ApplicationCreateInput {
  id?: Maybe<ID_Input>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
  candidate: CandidateCreateOneWithoutApplicationsInput;
  opening: OpeningCreateOneWithoutApplicationsInput;
  steps?: Maybe<ApplicationStepCreateManyWithoutApplicationInput>;
}

export interface StepWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<StepWhereInput[] | StepWhereInput>;
  OR?: Maybe<StepWhereInput[] | StepWhereInput>;
  NOT?: Maybe<StepWhereInput[] | StepWhereInput>;
}

export interface CandidateCreateWithoutApplicationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  title: String;
  email: String;
  yearsOfExperience?: Maybe<Int>;
  phone?: Maybe<String>;
  skypeId?: Maybe<String>;
  salaryExpectation?: Maybe<Float>;
  cv?: Maybe<String>;
  seniority: Seniority;
  status: Status;
}

export interface ApplicationStepWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  application?: Maybe<ApplicationWhereInput>;
  step?: Maybe<StepWhereInput>;
  feedback?: Maybe<String>;
  feedback_not?: Maybe<String>;
  feedback_in?: Maybe<String[] | String>;
  feedback_not_in?: Maybe<String[] | String>;
  feedback_lt?: Maybe<String>;
  feedback_lte?: Maybe<String>;
  feedback_gt?: Maybe<String>;
  feedback_gte?: Maybe<String>;
  feedback_contains?: Maybe<String>;
  feedback_not_contains?: Maybe<String>;
  feedback_starts_with?: Maybe<String>;
  feedback_not_starts_with?: Maybe<String>;
  feedback_ends_with?: Maybe<String>;
  feedback_not_ends_with?: Maybe<String>;
  completionDate?: Maybe<DateTimeInput>;
  completionDate_not?: Maybe<DateTimeInput>;
  completionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  completionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  completionDate_lt?: Maybe<DateTimeInput>;
  completionDate_lte?: Maybe<DateTimeInput>;
  completionDate_gt?: Maybe<DateTimeInput>;
  completionDate_gte?: Maybe<DateTimeInput>;
  result?: Maybe<Result>;
  result_not?: Maybe<Result>;
  result_in?: Maybe<Result[] | Result>;
  result_not_in?: Maybe<Result[] | Result>;
  responsable?: Maybe<String>;
  responsable_not?: Maybe<String>;
  responsable_in?: Maybe<String[] | String>;
  responsable_not_in?: Maybe<String[] | String>;
  responsable_lt?: Maybe<String>;
  responsable_lte?: Maybe<String>;
  responsable_gt?: Maybe<String>;
  responsable_gte?: Maybe<String>;
  responsable_contains?: Maybe<String>;
  responsable_not_contains?: Maybe<String>;
  responsable_starts_with?: Maybe<String>;
  responsable_not_starts_with?: Maybe<String>;
  responsable_ends_with?: Maybe<String>;
  responsable_not_ends_with?: Maybe<String>;
  AND?: Maybe<ApplicationStepWhereInput[] | ApplicationStepWhereInput>;
  OR?: Maybe<ApplicationStepWhereInput[] | ApplicationStepWhereInput>;
  NOT?: Maybe<ApplicationStepWhereInput[] | ApplicationStepWhereInput>;
}

export interface OpeningCreateWithoutApplicationsInput {
  id?: Maybe<ID_Input>;
  jobTitle: String;
  jobDescription: String;
  company?: Maybe<String>;
  maxSalaryRange?: Maybe<Float>;
  steps?: Maybe<StepCreateManyInput>;
  status?: Maybe<OpeningStatus>;
}

export interface ApplicationUpdateManyWithoutCandidateInput {
  create?: Maybe<
    | ApplicationCreateWithoutCandidateInput[]
    | ApplicationCreateWithoutCandidateInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutCandidateInput[]
    | ApplicationUpdateWithWhereUniqueWithoutCandidateInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutCandidateInput[]
    | ApplicationUpsertWithWhereUniqueWithoutCandidateInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface OpeningSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OpeningWhereInput>;
  AND?: Maybe<OpeningSubscriptionWhereInput[] | OpeningSubscriptionWhereInput>;
  OR?: Maybe<OpeningSubscriptionWhereInput[] | OpeningSubscriptionWhereInput>;
  NOT?: Maybe<OpeningSubscriptionWhereInput[] | OpeningSubscriptionWhereInput>;
}

export interface CandidateUpdateInput {
  name?: Maybe<String>;
  title?: Maybe<String>;
  email?: Maybe<String>;
  yearsOfExperience?: Maybe<Int>;
  phone?: Maybe<String>;
  skypeId?: Maybe<String>;
  salaryExpectation?: Maybe<Float>;
  cv?: Maybe<String>;
  applications?: Maybe<ApplicationUpdateManyWithoutCandidateInput>;
  seniority?: Maybe<Seniority>;
  status?: Maybe<Status>;
}

export interface TemplateStepUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface StepUpsertNestedInput {
  update: StepUpdateDataInput;
  create: StepCreateInput;
}

export interface StepUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ApplicationStepUpsertWithWhereUniqueWithoutApplicationInput {
  where: ApplicationStepWhereUniqueInput;
  update: ApplicationStepUpdateWithoutApplicationDataInput;
  create: ApplicationStepCreateWithoutApplicationInput;
}

export interface ApplicationUpsertWithWhereUniqueWithoutOpeningInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutOpeningDataInput;
  create: ApplicationCreateWithoutOpeningInput;
}

export interface ApplicationStepScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  feedback?: Maybe<String>;
  feedback_not?: Maybe<String>;
  feedback_in?: Maybe<String[] | String>;
  feedback_not_in?: Maybe<String[] | String>;
  feedback_lt?: Maybe<String>;
  feedback_lte?: Maybe<String>;
  feedback_gt?: Maybe<String>;
  feedback_gte?: Maybe<String>;
  feedback_contains?: Maybe<String>;
  feedback_not_contains?: Maybe<String>;
  feedback_starts_with?: Maybe<String>;
  feedback_not_starts_with?: Maybe<String>;
  feedback_ends_with?: Maybe<String>;
  feedback_not_ends_with?: Maybe<String>;
  completionDate?: Maybe<DateTimeInput>;
  completionDate_not?: Maybe<DateTimeInput>;
  completionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  completionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  completionDate_lt?: Maybe<DateTimeInput>;
  completionDate_lte?: Maybe<DateTimeInput>;
  completionDate_gt?: Maybe<DateTimeInput>;
  completionDate_gte?: Maybe<DateTimeInput>;
  result?: Maybe<Result>;
  result_not?: Maybe<Result>;
  result_in?: Maybe<Result[] | Result>;
  result_not_in?: Maybe<Result[] | Result>;
  responsable?: Maybe<String>;
  responsable_not?: Maybe<String>;
  responsable_in?: Maybe<String[] | String>;
  responsable_not_in?: Maybe<String[] | String>;
  responsable_lt?: Maybe<String>;
  responsable_lte?: Maybe<String>;
  responsable_gt?: Maybe<String>;
  responsable_gte?: Maybe<String>;
  responsable_contains?: Maybe<String>;
  responsable_not_contains?: Maybe<String>;
  responsable_starts_with?: Maybe<String>;
  responsable_not_starts_with?: Maybe<String>;
  responsable_ends_with?: Maybe<String>;
  responsable_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ApplicationStepScalarWhereInput[] | ApplicationStepScalarWhereInput
  >;
  OR?: Maybe<
    ApplicationStepScalarWhereInput[] | ApplicationStepScalarWhereInput
  >;
  NOT?: Maybe<
    ApplicationStepScalarWhereInput[] | ApplicationStepScalarWhereInput
  >;
}

export interface ApplicationUpdateManyWithoutOpeningInput {
  create?: Maybe<
    | ApplicationCreateWithoutOpeningInput[]
    | ApplicationCreateWithoutOpeningInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutOpeningInput[]
    | ApplicationUpdateWithWhereUniqueWithoutOpeningInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutOpeningInput[]
    | ApplicationUpsertWithWhereUniqueWithoutOpeningInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface ApplicationStepUpdateManyWithWhereNestedInput {
  where: ApplicationStepScalarWhereInput;
  data: ApplicationStepUpdateManyDataInput;
}

export interface ApplicationCreateManyWithoutOpeningInput {
  create?: Maybe<
    | ApplicationCreateWithoutOpeningInput[]
    | ApplicationCreateWithoutOpeningInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface ApplicationStepUpdateManyDataInput {
  feedback?: Maybe<String>;
  completionDate?: Maybe<DateTimeInput>;
  result?: Maybe<Result>;
  responsable?: Maybe<String>;
}

export interface ApplicationUpdateManyDataInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface ApplicationUpdateManyMutationInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
}

export interface ApplicationUpsertWithWhereUniqueWithoutCandidateInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutCandidateDataInput;
  create: ApplicationCreateWithoutCandidateInput;
}

export interface ApplicationCreateWithoutCandidateInput {
  id?: Maybe<ID_Input>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
  opening: OpeningCreateOneWithoutApplicationsInput;
  steps?: Maybe<ApplicationStepCreateManyWithoutApplicationInput>;
}

export interface CandidateCreateOneWithoutApplicationsInput {
  create?: Maybe<CandidateCreateWithoutApplicationsInput>;
  connect?: Maybe<CandidateWhereUniqueInput>;
}

export interface ApplicationCreateManyWithoutCandidateInput {
  create?: Maybe<
    | ApplicationCreateWithoutCandidateInput[]
    | ApplicationCreateWithoutCandidateInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface TemplateStepSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TemplateStepWhereInput>;
  AND?: Maybe<
    TemplateStepSubscriptionWhereInput[] | TemplateStepSubscriptionWhereInput
  >;
  OR?: Maybe<
    TemplateStepSubscriptionWhereInput[] | TemplateStepSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TemplateStepSubscriptionWhereInput[] | TemplateStepSubscriptionWhereInput
  >;
}

export interface ApplicationStepCreateInput {
  id?: Maybe<ID_Input>;
  application?: Maybe<ApplicationCreateOneWithoutStepsInput>;
  step: StepCreateOneInput;
  feedback?: Maybe<String>;
  completionDate?: Maybe<DateTimeInput>;
  result?: Maybe<Result>;
  responsable?: Maybe<String>;
}

export interface TemplateStepUpdateInput {
  steps?: Maybe<StepUpdateManyInput>;
  name?: Maybe<String>;
}

export interface ApplicationCreateOneWithoutStepsInput {
  create?: Maybe<ApplicationCreateWithoutStepsInput>;
  connect?: Maybe<ApplicationWhereUniqueInput>;
}

export type OpeningWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ApplicationCreateWithoutStepsInput {
  id?: Maybe<ID_Input>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
  candidate: CandidateCreateOneWithoutApplicationsInput;
  opening: OpeningCreateOneWithoutApplicationsInput;
}

export interface CandidateUpdateManyMutationInput {
  name?: Maybe<String>;
  title?: Maybe<String>;
  email?: Maybe<String>;
  yearsOfExperience?: Maybe<Int>;
  phone?: Maybe<String>;
  skypeId?: Maybe<String>;
  salaryExpectation?: Maybe<Float>;
  cv?: Maybe<String>;
  seniority?: Maybe<Seniority>;
  status?: Maybe<Status>;
}

export interface ApplicationStepUpdateInput {
  application?: Maybe<ApplicationUpdateOneWithoutStepsInput>;
  step?: Maybe<StepUpdateOneRequiredInput>;
  feedback?: Maybe<String>;
  completionDate?: Maybe<DateTimeInput>;
  result?: Maybe<Result>;
  responsable?: Maybe<String>;
}

export interface ApplicationStepSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplicationStepWhereInput>;
  AND?: Maybe<
    | ApplicationStepSubscriptionWhereInput[]
    | ApplicationStepSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ApplicationStepSubscriptionWhereInput[]
    | ApplicationStepSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ApplicationStepSubscriptionWhereInput[]
    | ApplicationStepSubscriptionWhereInput
  >;
}

export interface ApplicationStepUpdateManyMutationInput {
  feedback?: Maybe<String>;
  completionDate?: Maybe<DateTimeInput>;
  result?: Maybe<Result>;
  responsable?: Maybe<String>;
}

export interface ApplicationUpsertWithoutStepsInput {
  update: ApplicationUpdateWithoutStepsDataInput;
  create: ApplicationCreateWithoutStepsInput;
}

export interface ApplicationUpdateWithoutStepsDataInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutApplicationsInput>;
  opening?: Maybe<OpeningUpdateOneRequiredWithoutApplicationsInput>;
}

export interface ApplicationUpdateOneWithoutStepsInput {
  create?: Maybe<ApplicationCreateWithoutStepsInput>;
  update?: Maybe<ApplicationUpdateWithoutStepsDataInput>;
  upsert?: Maybe<ApplicationUpsertWithoutStepsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ApplicationWhereUniqueInput>;
}

export interface StepUpdateInput {
  name?: Maybe<String>;
}

export interface OpeningCreateOneWithoutApplicationsInput {
  create?: Maybe<OpeningCreateWithoutApplicationsInput>;
  connect?: Maybe<OpeningWhereUniqueInput>;
}

export interface ApplicationUpdateManyWithWhereNestedInput {
  where: ApplicationScalarWhereInput;
  data: ApplicationUpdateManyDataInput;
}

export interface ApplicationCreateWithoutOpeningInput {
  id?: Maybe<ID_Input>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  feedback?: Maybe<String>;
  responsable?: Maybe<String>;
  result?: Maybe<Result>;
  candidate: CandidateCreateOneWithoutApplicationsInput;
  steps?: Maybe<ApplicationStepCreateManyWithoutApplicationInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TemplateStepPreviousValues {
  name?: String;
  id: ID_Output;
}

export interface TemplateStepPreviousValuesPromise
  extends Promise<TemplateStepPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  id: () => Promise<ID_Output>;
}

export interface TemplateStepPreviousValuesSubscription
  extends Promise<AsyncIterator<TemplateStepPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface CandidateConnection {
  pageInfo: PageInfo;
  edges: CandidateEdge[];
}

export interface CandidateConnectionPromise
  extends Promise<CandidateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CandidateEdge>>() => T;
  aggregate: <T = AggregateCandidatePromise>() => T;
}

export interface CandidateConnectionSubscription
  extends Promise<AsyncIterator<CandidateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CandidateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCandidateSubscription>() => T;
}

export interface OpeningPreviousValues {
  id: ID_Output;
  jobTitle: String;
  jobDescription: String;
  company?: String;
  maxSalaryRange?: Float;
  status?: OpeningStatus;
}

export interface OpeningPreviousValuesPromise
  extends Promise<OpeningPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  jobTitle: () => Promise<String>;
  jobDescription: () => Promise<String>;
  company: () => Promise<String>;
  maxSalaryRange: () => Promise<Float>;
  status: () => Promise<OpeningStatus>;
}

export interface OpeningPreviousValuesSubscription
  extends Promise<AsyncIterator<OpeningPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  jobDescription: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  maxSalaryRange: () => Promise<AsyncIterator<Float>>;
  status: () => Promise<AsyncIterator<OpeningStatus>>;
}

export interface Candidate {
  id: ID_Output;
  name: String;
  title: String;
  email: String;
  yearsOfExperience?: Int;
  phone?: String;
  skypeId?: String;
  salaryExpectation?: Float;
  cv?: String;
  seniority: Seniority;
  status: Status;
}

export interface CandidatePromise extends Promise<Candidate>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  title: () => Promise<String>;
  email: () => Promise<String>;
  yearsOfExperience: () => Promise<Int>;
  phone: () => Promise<String>;
  skypeId: () => Promise<String>;
  salaryExpectation: () => Promise<Float>;
  cv: () => Promise<String>;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seniority: () => Promise<Seniority>;
  status: () => Promise<Status>;
}

export interface CandidateSubscription
  extends Promise<AsyncIterator<Candidate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  yearsOfExperience: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
  skypeId: () => Promise<AsyncIterator<String>>;
  salaryExpectation: () => Promise<AsyncIterator<Float>>;
  cv: () => Promise<AsyncIterator<String>>;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seniority: () => Promise<AsyncIterator<Seniority>>;
  status: () => Promise<AsyncIterator<Status>>;
}

export interface CandidateNullablePromise
  extends Promise<Candidate | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  title: () => Promise<String>;
  email: () => Promise<String>;
  yearsOfExperience: () => Promise<Int>;
  phone: () => Promise<String>;
  skypeId: () => Promise<String>;
  salaryExpectation: () => Promise<Float>;
  cv: () => Promise<String>;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seniority: () => Promise<Seniority>;
  status: () => Promise<Status>;
}

export interface ApplicationStepEdge {
  node: ApplicationStep;
  cursor: String;
}

export interface ApplicationStepEdgePromise
  extends Promise<ApplicationStepEdge>,
    Fragmentable {
  node: <T = ApplicationStepPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationStepEdgeSubscription
  extends Promise<AsyncIterator<ApplicationStepEdge>>,
    Fragmentable {
  node: <T = ApplicationStepSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApplicationStep {
  count: Int;
}

export interface AggregateApplicationStepPromise
  extends Promise<AggregateApplicationStep>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationStepSubscription
  extends Promise<AsyncIterator<AggregateApplicationStep>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Opening {
  id: ID_Output;
  jobTitle: String;
  jobDescription: String;
  company?: String;
  maxSalaryRange?: Float;
  status?: OpeningStatus;
}

export interface OpeningPromise extends Promise<Opening>, Fragmentable {
  id: () => Promise<ID_Output>;
  jobTitle: () => Promise<String>;
  jobDescription: () => Promise<String>;
  company: () => Promise<String>;
  maxSalaryRange: () => Promise<Float>;
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<OpeningStatus>;
}

export interface OpeningSubscription
  extends Promise<AsyncIterator<Opening>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  jobDescription: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  maxSalaryRange: () => Promise<AsyncIterator<Float>>;
  steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<OpeningStatus>>;
}

export interface OpeningNullablePromise
  extends Promise<Opening | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  jobTitle: () => Promise<String>;
  jobDescription: () => Promise<String>;
  company: () => Promise<String>;
  maxSalaryRange: () => Promise<Float>;
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<OpeningStatus>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateTemplateStep {
  count: Int;
}

export interface AggregateTemplateStepPromise
  extends Promise<AggregateTemplateStep>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTemplateStepSubscription
  extends Promise<AsyncIterator<AggregateTemplateStep>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ApplicationStepConnection {
  pageInfo: PageInfo;
  edges: ApplicationStepEdge[];
}

export interface ApplicationStepConnectionPromise
  extends Promise<ApplicationStepConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationStepEdge>>() => T;
  aggregate: <T = AggregateApplicationStepPromise>() => T;
}

export interface ApplicationStepConnectionSubscription
  extends Promise<AsyncIterator<ApplicationStepConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicationStepEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicationStepSubscription>() => T;
}

export interface TemplateStepConnection {
  pageInfo: PageInfo;
  edges: TemplateStepEdge[];
}

export interface TemplateStepConnectionPromise
  extends Promise<TemplateStepConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TemplateStepEdge>>() => T;
  aggregate: <T = AggregateTemplateStepPromise>() => T;
}

export interface TemplateStepConnectionSubscription
  extends Promise<AsyncIterator<TemplateStepConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TemplateStepEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTemplateStepSubscription>() => T;
}

export interface AggregateApplication {
  count: Int;
}

export interface AggregateApplicationPromise
  extends Promise<AggregateApplication>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationSubscription
  extends Promise<AsyncIterator<AggregateApplication>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TemplateStep {
  name?: String;
  id: ID_Output;
}

export interface TemplateStepPromise
  extends Promise<TemplateStep>,
    Fragmentable {
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  id: () => Promise<ID_Output>;
}

export interface TemplateStepSubscription
  extends Promise<AsyncIterator<TemplateStep>>,
    Fragmentable {
  steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TemplateStepNullablePromise
  extends Promise<TemplateStep | null>,
    Fragmentable {
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  id: () => Promise<ID_Output>;
}

export interface ApplicationEdge {
  node: Application;
  cursor: String;
}

export interface ApplicationEdgePromise
  extends Promise<ApplicationEdge>,
    Fragmentable {
  node: <T = ApplicationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationEdgeSubscription
  extends Promise<AsyncIterator<ApplicationEdge>>,
    Fragmentable {
  node: <T = ApplicationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StepEdge {
  node: Step;
  cursor: String;
}

export interface StepEdgePromise extends Promise<StepEdge>, Fragmentable {
  node: <T = StepPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StepEdgeSubscription
  extends Promise<AsyncIterator<StepEdge>>,
    Fragmentable {
  node: <T = StepSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Application {
  id: ID_Output;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  feedback?: String;
  responsable?: String;
  result?: Result;
}

export interface ApplicationPromise extends Promise<Application>, Fragmentable {
  id: () => Promise<ID_Output>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  feedback: () => Promise<String>;
  responsable: () => Promise<String>;
  result: () => Promise<Result>;
  candidate: <T = CandidatePromise>() => T;
  opening: <T = OpeningPromise>() => T;
  steps: <T = FragmentableArray<ApplicationStep>>(args?: {
    where?: ApplicationStepWhereInput;
    orderBy?: ApplicationStepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ApplicationSubscription
  extends Promise<AsyncIterator<Application>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  feedback: () => Promise<AsyncIterator<String>>;
  responsable: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<Result>>;
  candidate: <T = CandidateSubscription>() => T;
  opening: <T = OpeningSubscription>() => T;
  steps: <T = Promise<AsyncIterator<ApplicationStepSubscription>>>(args?: {
    where?: ApplicationStepWhereInput;
    orderBy?: ApplicationStepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ApplicationNullablePromise
  extends Promise<Application | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  feedback: () => Promise<String>;
  responsable: () => Promise<String>;
  result: () => Promise<Result>;
  candidate: <T = CandidatePromise>() => T;
  opening: <T = OpeningPromise>() => T;
  steps: <T = FragmentableArray<ApplicationStep>>(args?: {
    where?: ApplicationStepWhereInput;
    orderBy?: ApplicationStepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateOpening {
  count: Int;
}

export interface AggregateOpeningPromise
  extends Promise<AggregateOpening>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOpeningSubscription
  extends Promise<AsyncIterator<AggregateOpening>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ApplicationSubscriptionPayload {
  mutation: MutationType;
  node: Application;
  updatedFields: String[];
  previousValues: ApplicationPreviousValues;
}

export interface ApplicationSubscriptionPayloadPromise
  extends Promise<ApplicationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationPreviousValuesPromise>() => T;
}

export interface ApplicationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicationPreviousValuesSubscription>() => T;
}

export interface OpeningConnection {
  pageInfo: PageInfo;
  edges: OpeningEdge[];
}

export interface OpeningConnectionPromise
  extends Promise<OpeningConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OpeningEdge>>() => T;
  aggregate: <T = AggregateOpeningPromise>() => T;
}

export interface OpeningConnectionSubscription
  extends Promise<AsyncIterator<OpeningConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OpeningEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOpeningSubscription>() => T;
}

export interface ApplicationPreviousValues {
  id: ID_Output;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  feedback?: String;
  responsable?: String;
  result?: Result;
}

export interface ApplicationPreviousValuesPromise
  extends Promise<ApplicationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  feedback: () => Promise<String>;
  responsable: () => Promise<String>;
  result: () => Promise<Result>;
}

export interface ApplicationPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  feedback: () => Promise<AsyncIterator<String>>;
  responsable: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<Result>>;
}

export interface AggregateCandidate {
  count: Int;
}

export interface AggregateCandidatePromise
  extends Promise<AggregateCandidate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCandidateSubscription
  extends Promise<AsyncIterator<AggregateCandidate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ApplicationStep {
  id: ID_Output;
  feedback?: String;
  completionDate?: DateTimeOutput;
  result?: Result;
  responsable?: String;
}

export interface ApplicationStepPromise
  extends Promise<ApplicationStep>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  application: <T = ApplicationPromise>() => T;
  step: <T = StepPromise>() => T;
  feedback: () => Promise<String>;
  completionDate: () => Promise<DateTimeOutput>;
  result: () => Promise<Result>;
  responsable: () => Promise<String>;
}

export interface ApplicationStepSubscription
  extends Promise<AsyncIterator<ApplicationStep>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  application: <T = ApplicationSubscription>() => T;
  step: <T = StepSubscription>() => T;
  feedback: () => Promise<AsyncIterator<String>>;
  completionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  result: () => Promise<AsyncIterator<Result>>;
  responsable: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationStepNullablePromise
  extends Promise<ApplicationStep | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  application: <T = ApplicationPromise>() => T;
  step: <T = StepPromise>() => T;
  feedback: () => Promise<String>;
  completionDate: () => Promise<DateTimeOutput>;
  result: () => Promise<Result>;
  responsable: () => Promise<String>;
}

export interface Step {
  id: ID_Output;
  name: String;
}

export interface StepPromise extends Promise<Step>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StepSubscription
  extends Promise<AsyncIterator<Step>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StepNullablePromise
  extends Promise<Step | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ApplicationStepSubscriptionPayload {
  mutation: MutationType;
  node: ApplicationStep;
  updatedFields: String[];
  previousValues: ApplicationStepPreviousValues;
}

export interface ApplicationStepSubscriptionPayloadPromise
  extends Promise<ApplicationStepSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationStepPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationStepPreviousValuesPromise>() => T;
}

export interface ApplicationStepSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationStepSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationStepSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicationStepPreviousValuesSubscription>() => T;
}

export interface TemplateStepEdge {
  node: TemplateStep;
  cursor: String;
}

export interface TemplateStepEdgePromise
  extends Promise<TemplateStepEdge>,
    Fragmentable {
  node: <T = TemplateStepPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TemplateStepEdgeSubscription
  extends Promise<AsyncIterator<TemplateStepEdge>>,
    Fragmentable {
  node: <T = TemplateStepSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationStepPreviousValues {
  id: ID_Output;
  feedback?: String;
  completionDate?: DateTimeOutput;
  result?: Result;
  responsable?: String;
}

export interface ApplicationStepPreviousValuesPromise
  extends Promise<ApplicationStepPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  feedback: () => Promise<String>;
  completionDate: () => Promise<DateTimeOutput>;
  result: () => Promise<Result>;
  responsable: () => Promise<String>;
}

export interface ApplicationStepPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationStepPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  feedback: () => Promise<AsyncIterator<String>>;
  completionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  result: () => Promise<AsyncIterator<Result>>;
  responsable: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStep {
  count: Int;
}

export interface AggregateStepPromise
  extends Promise<AggregateStep>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStepSubscription
  extends Promise<AsyncIterator<AggregateStep>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface OpeningEdge {
  node: Opening;
  cursor: String;
}

export interface OpeningEdgePromise extends Promise<OpeningEdge>, Fragmentable {
  node: <T = OpeningPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OpeningEdgeSubscription
  extends Promise<AsyncIterator<OpeningEdge>>,
    Fragmentable {
  node: <T = OpeningSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CandidateEdge {
  node: Candidate;
  cursor: String;
}

export interface CandidateEdgePromise
  extends Promise<CandidateEdge>,
    Fragmentable {
  node: <T = CandidatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CandidateEdgeSubscription
  extends Promise<AsyncIterator<CandidateEdge>>,
    Fragmentable {
  node: <T = CandidateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OpeningSubscriptionPayload {
  mutation: MutationType;
  node: Opening;
  updatedFields: String[];
  previousValues: OpeningPreviousValues;
}

export interface OpeningSubscriptionPayloadPromise
  extends Promise<OpeningSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OpeningPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OpeningPreviousValuesPromise>() => T;
}

export interface OpeningSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OpeningSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OpeningSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OpeningPreviousValuesSubscription>() => T;
}

export interface ApplicationConnection {
  pageInfo: PageInfo;
  edges: ApplicationEdge[];
}

export interface ApplicationConnectionPromise
  extends Promise<ApplicationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationEdge>>() => T;
  aggregate: <T = AggregateApplicationPromise>() => T;
}

export interface ApplicationConnectionSubscription
  extends Promise<AsyncIterator<ApplicationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicationSubscription>() => T;
}

export interface CandidatePreviousValues {
  id: ID_Output;
  name: String;
  title: String;
  email: String;
  yearsOfExperience?: Int;
  phone?: String;
  skypeId?: String;
  salaryExpectation?: Float;
  cv?: String;
  seniority: Seniority;
  status: Status;
}

export interface CandidatePreviousValuesPromise
  extends Promise<CandidatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  title: () => Promise<String>;
  email: () => Promise<String>;
  yearsOfExperience: () => Promise<Int>;
  phone: () => Promise<String>;
  skypeId: () => Promise<String>;
  salaryExpectation: () => Promise<Float>;
  cv: () => Promise<String>;
  seniority: () => Promise<Seniority>;
  status: () => Promise<Status>;
}

export interface CandidatePreviousValuesSubscription
  extends Promise<AsyncIterator<CandidatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  yearsOfExperience: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
  skypeId: () => Promise<AsyncIterator<String>>;
  salaryExpectation: () => Promise<AsyncIterator<Float>>;
  cv: () => Promise<AsyncIterator<String>>;
  seniority: () => Promise<AsyncIterator<Seniority>>;
  status: () => Promise<AsyncIterator<Status>>;
}

export interface CandidateSubscriptionPayload {
  mutation: MutationType;
  node: Candidate;
  updatedFields: String[];
  previousValues: CandidatePreviousValues;
}

export interface CandidateSubscriptionPayloadPromise
  extends Promise<CandidateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CandidatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CandidatePreviousValuesPromise>() => T;
}

export interface CandidateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CandidateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CandidateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CandidatePreviousValuesSubscription>() => T;
}

export interface TemplateStepSubscriptionPayload {
  mutation: MutationType;
  node: TemplateStep;
  updatedFields: String[];
  previousValues: TemplateStepPreviousValues;
}

export interface TemplateStepSubscriptionPayloadPromise
  extends Promise<TemplateStepSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TemplateStepPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TemplateStepPreviousValuesPromise>() => T;
}

export interface TemplateStepSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TemplateStepSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TemplateStepSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TemplateStepPreviousValuesSubscription>() => T;
}

export interface StepSubscriptionPayload {
  mutation: MutationType;
  node: Step;
  updatedFields: String[];
  previousValues: StepPreviousValues;
}

export interface StepSubscriptionPayloadPromise
  extends Promise<StepSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StepPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StepPreviousValuesPromise>() => T;
}

export interface StepSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StepSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StepPreviousValuesSubscription>() => T;
}

export interface StepConnection {
  pageInfo: PageInfo;
  edges: StepEdge[];
}

export interface StepConnectionPromise
  extends Promise<StepConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StepEdge>>() => T;
  aggregate: <T = AggregateStepPromise>() => T;
}

export interface StepConnectionSubscription
  extends Promise<AsyncIterator<StepConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StepEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStepSubscription>() => T;
}

export interface StepPreviousValues {
  id: ID_Output;
  name: String;
}

export interface StepPreviousValuesPromise
  extends Promise<StepPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StepPreviousValuesSubscription
  extends Promise<AsyncIterator<StepPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Candidate",
    embedded: false
  },
  {
    name: "Seniority",
    embedded: false
  },
  {
    name: "Application",
    embedded: false
  },
  {
    name: "Result",
    embedded: false
  },
  {
    name: "Status",
    embedded: false
  },
  {
    name: "Opening",
    embedded: false
  },
  {
    name: "OpeningStatus",
    embedded: false
  },
  {
    name: "ApplicationStep",
    embedded: false
  },
  {
    name: "Step",
    embedded: false
  },
  {
    name: "TemplateStep",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
