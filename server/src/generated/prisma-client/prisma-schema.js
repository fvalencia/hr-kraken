module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateApplication {
  count: Int!
}

type AggregateApplicationStep {
  count: Int!
}

type AggregateCandidate {
  count: Int!
}

type AggregateOpening {
  count: Int!
}

type AggregateStep {
  count: Int!
}

type AggregateTemplateStep {
  count: Int!
}

type Application {
  id: ID!
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  candidate: Candidate!
  opening: Opening!
  steps(where: ApplicationStepWhereInput, orderBy: ApplicationStepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ApplicationStep!]
}

type ApplicationConnection {
  pageInfo: PageInfo!
  edges: [ApplicationEdge]!
  aggregate: AggregateApplication!
}

input ApplicationCreateInput {
  id: ID
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  candidate: CandidateCreateOneWithoutApplicationsInput!
  opening: OpeningCreateOneWithoutApplicationsInput!
  steps: ApplicationStepCreateManyWithoutApplicationInput
}

input ApplicationCreateManyWithoutCandidateInput {
  create: [ApplicationCreateWithoutCandidateInput!]
  connect: [ApplicationWhereUniqueInput!]
}

input ApplicationCreateManyWithoutOpeningInput {
  create: [ApplicationCreateWithoutOpeningInput!]
  connect: [ApplicationWhereUniqueInput!]
}

input ApplicationCreateOneWithoutStepsInput {
  create: ApplicationCreateWithoutStepsInput
  connect: ApplicationWhereUniqueInput
}

input ApplicationCreateWithoutCandidateInput {
  id: ID
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  opening: OpeningCreateOneWithoutApplicationsInput!
  steps: ApplicationStepCreateManyWithoutApplicationInput
}

input ApplicationCreateWithoutOpeningInput {
  id: ID
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  candidate: CandidateCreateOneWithoutApplicationsInput!
  steps: ApplicationStepCreateManyWithoutApplicationInput
}

input ApplicationCreateWithoutStepsInput {
  id: ID
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  candidate: CandidateCreateOneWithoutApplicationsInput!
  opening: OpeningCreateOneWithoutApplicationsInput!
}

type ApplicationEdge {
  node: Application!
  cursor: String!
}

enum ApplicationOrderByInput {
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  feedback_ASC
  feedback_DESC
  responsible_ASC
  responsible_DESC
  result_ASC
  result_DESC
}

type ApplicationPreviousValues {
  id: ID!
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
}

input ApplicationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  feedback: String
  feedback_not: String
  feedback_in: [String!]
  feedback_not_in: [String!]
  feedback_lt: String
  feedback_lte: String
  feedback_gt: String
  feedback_gte: String
  feedback_contains: String
  feedback_not_contains: String
  feedback_starts_with: String
  feedback_not_starts_with: String
  feedback_ends_with: String
  feedback_not_ends_with: String
  responsible: String
  responsible_not: String
  responsible_in: [String!]
  responsible_not_in: [String!]
  responsible_lt: String
  responsible_lte: String
  responsible_gt: String
  responsible_gte: String
  responsible_contains: String
  responsible_not_contains: String
  responsible_starts_with: String
  responsible_not_starts_with: String
  responsible_ends_with: String
  responsible_not_ends_with: String
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  AND: [ApplicationScalarWhereInput!]
  OR: [ApplicationScalarWhereInput!]
  NOT: [ApplicationScalarWhereInput!]
}

type ApplicationStep {
  id: ID!
  application: Application
  step: Step!
  feedback: String
  completionDate: DateTime
  result: Result
  responsible: String
}

type ApplicationStepConnection {
  pageInfo: PageInfo!
  edges: [ApplicationStepEdge]!
  aggregate: AggregateApplicationStep!
}

input ApplicationStepCreateInput {
  id: ID
  application: ApplicationCreateOneWithoutStepsInput
  step: StepCreateOneInput!
  feedback: String
  completionDate: DateTime
  result: Result
  responsible: String
}

input ApplicationStepCreateManyWithoutApplicationInput {
  create: [ApplicationStepCreateWithoutApplicationInput!]
  connect: [ApplicationStepWhereUniqueInput!]
}

input ApplicationStepCreateWithoutApplicationInput {
  id: ID
  step: StepCreateOneInput!
  feedback: String
  completionDate: DateTime
  result: Result
  responsible: String
}

type ApplicationStepEdge {
  node: ApplicationStep!
  cursor: String!
}

enum ApplicationStepOrderByInput {
  id_ASC
  id_DESC
  feedback_ASC
  feedback_DESC
  completionDate_ASC
  completionDate_DESC
  result_ASC
  result_DESC
  responsible_ASC
  responsible_DESC
}

type ApplicationStepPreviousValues {
  id: ID!
  feedback: String
  completionDate: DateTime
  result: Result
  responsible: String
}

input ApplicationStepScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  feedback: String
  feedback_not: String
  feedback_in: [String!]
  feedback_not_in: [String!]
  feedback_lt: String
  feedback_lte: String
  feedback_gt: String
  feedback_gte: String
  feedback_contains: String
  feedback_not_contains: String
  feedback_starts_with: String
  feedback_not_starts_with: String
  feedback_ends_with: String
  feedback_not_ends_with: String
  completionDate: DateTime
  completionDate_not: DateTime
  completionDate_in: [DateTime!]
  completionDate_not_in: [DateTime!]
  completionDate_lt: DateTime
  completionDate_lte: DateTime
  completionDate_gt: DateTime
  completionDate_gte: DateTime
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  responsible: String
  responsible_not: String
  responsible_in: [String!]
  responsible_not_in: [String!]
  responsible_lt: String
  responsible_lte: String
  responsible_gt: String
  responsible_gte: String
  responsible_contains: String
  responsible_not_contains: String
  responsible_starts_with: String
  responsible_not_starts_with: String
  responsible_ends_with: String
  responsible_not_ends_with: String
  AND: [ApplicationStepScalarWhereInput!]
  OR: [ApplicationStepScalarWhereInput!]
  NOT: [ApplicationStepScalarWhereInput!]
}

type ApplicationStepSubscriptionPayload {
  mutation: MutationType!
  node: ApplicationStep
  updatedFields: [String!]
  previousValues: ApplicationStepPreviousValues
}

input ApplicationStepSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ApplicationStepWhereInput
  AND: [ApplicationStepSubscriptionWhereInput!]
  OR: [ApplicationStepSubscriptionWhereInput!]
  NOT: [ApplicationStepSubscriptionWhereInput!]
}

input ApplicationStepUpdateInput {
  application: ApplicationUpdateOneWithoutStepsInput
  step: StepUpdateOneRequiredInput
  feedback: String
  completionDate: DateTime
  result: Result
  responsible: String
}

input ApplicationStepUpdateManyDataInput {
  feedback: String
  completionDate: DateTime
  result: Result
  responsible: String
}

input ApplicationStepUpdateManyMutationInput {
  feedback: String
  completionDate: DateTime
  result: Result
  responsible: String
}

input ApplicationStepUpdateManyWithoutApplicationInput {
  create: [ApplicationStepCreateWithoutApplicationInput!]
  delete: [ApplicationStepWhereUniqueInput!]
  connect: [ApplicationStepWhereUniqueInput!]
  set: [ApplicationStepWhereUniqueInput!]
  disconnect: [ApplicationStepWhereUniqueInput!]
  update: [ApplicationStepUpdateWithWhereUniqueWithoutApplicationInput!]
  upsert: [ApplicationStepUpsertWithWhereUniqueWithoutApplicationInput!]
  deleteMany: [ApplicationStepScalarWhereInput!]
  updateMany: [ApplicationStepUpdateManyWithWhereNestedInput!]
}

input ApplicationStepUpdateManyWithWhereNestedInput {
  where: ApplicationStepScalarWhereInput!
  data: ApplicationStepUpdateManyDataInput!
}

input ApplicationStepUpdateWithoutApplicationDataInput {
  step: StepUpdateOneRequiredInput
  feedback: String
  completionDate: DateTime
  result: Result
  responsible: String
}

input ApplicationStepUpdateWithWhereUniqueWithoutApplicationInput {
  where: ApplicationStepWhereUniqueInput!
  data: ApplicationStepUpdateWithoutApplicationDataInput!
}

input ApplicationStepUpsertWithWhereUniqueWithoutApplicationInput {
  where: ApplicationStepWhereUniqueInput!
  update: ApplicationStepUpdateWithoutApplicationDataInput!
  create: ApplicationStepCreateWithoutApplicationInput!
}

input ApplicationStepWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  application: ApplicationWhereInput
  step: StepWhereInput
  feedback: String
  feedback_not: String
  feedback_in: [String!]
  feedback_not_in: [String!]
  feedback_lt: String
  feedback_lte: String
  feedback_gt: String
  feedback_gte: String
  feedback_contains: String
  feedback_not_contains: String
  feedback_starts_with: String
  feedback_not_starts_with: String
  feedback_ends_with: String
  feedback_not_ends_with: String
  completionDate: DateTime
  completionDate_not: DateTime
  completionDate_in: [DateTime!]
  completionDate_not_in: [DateTime!]
  completionDate_lt: DateTime
  completionDate_lte: DateTime
  completionDate_gt: DateTime
  completionDate_gte: DateTime
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  responsible: String
  responsible_not: String
  responsible_in: [String!]
  responsible_not_in: [String!]
  responsible_lt: String
  responsible_lte: String
  responsible_gt: String
  responsible_gte: String
  responsible_contains: String
  responsible_not_contains: String
  responsible_starts_with: String
  responsible_not_starts_with: String
  responsible_ends_with: String
  responsible_not_ends_with: String
  AND: [ApplicationStepWhereInput!]
  OR: [ApplicationStepWhereInput!]
  NOT: [ApplicationStepWhereInput!]
}

input ApplicationStepWhereUniqueInput {
  id: ID
}

type ApplicationSubscriptionPayload {
  mutation: MutationType!
  node: Application
  updatedFields: [String!]
  previousValues: ApplicationPreviousValues
}

input ApplicationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ApplicationWhereInput
  AND: [ApplicationSubscriptionWhereInput!]
  OR: [ApplicationSubscriptionWhereInput!]
  NOT: [ApplicationSubscriptionWhereInput!]
}

input ApplicationUpdateInput {
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  candidate: CandidateUpdateOneRequiredWithoutApplicationsInput
  opening: OpeningUpdateOneRequiredWithoutApplicationsInput
  steps: ApplicationStepUpdateManyWithoutApplicationInput
}

input ApplicationUpdateManyDataInput {
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
}

input ApplicationUpdateManyMutationInput {
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
}

input ApplicationUpdateManyWithoutCandidateInput {
  create: [ApplicationCreateWithoutCandidateInput!]
  delete: [ApplicationWhereUniqueInput!]
  connect: [ApplicationWhereUniqueInput!]
  set: [ApplicationWhereUniqueInput!]
  disconnect: [ApplicationWhereUniqueInput!]
  update: [ApplicationUpdateWithWhereUniqueWithoutCandidateInput!]
  upsert: [ApplicationUpsertWithWhereUniqueWithoutCandidateInput!]
  deleteMany: [ApplicationScalarWhereInput!]
  updateMany: [ApplicationUpdateManyWithWhereNestedInput!]
}

input ApplicationUpdateManyWithoutOpeningInput {
  create: [ApplicationCreateWithoutOpeningInput!]
  delete: [ApplicationWhereUniqueInput!]
  connect: [ApplicationWhereUniqueInput!]
  set: [ApplicationWhereUniqueInput!]
  disconnect: [ApplicationWhereUniqueInput!]
  update: [ApplicationUpdateWithWhereUniqueWithoutOpeningInput!]
  upsert: [ApplicationUpsertWithWhereUniqueWithoutOpeningInput!]
  deleteMany: [ApplicationScalarWhereInput!]
  updateMany: [ApplicationUpdateManyWithWhereNestedInput!]
}

input ApplicationUpdateManyWithWhereNestedInput {
  where: ApplicationScalarWhereInput!
  data: ApplicationUpdateManyDataInput!
}

input ApplicationUpdateOneWithoutStepsInput {
  create: ApplicationCreateWithoutStepsInput
  update: ApplicationUpdateWithoutStepsDataInput
  upsert: ApplicationUpsertWithoutStepsInput
  delete: Boolean
  disconnect: Boolean
  connect: ApplicationWhereUniqueInput
}

input ApplicationUpdateWithoutCandidateDataInput {
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  opening: OpeningUpdateOneRequiredWithoutApplicationsInput
  steps: ApplicationStepUpdateManyWithoutApplicationInput
}

input ApplicationUpdateWithoutOpeningDataInput {
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  candidate: CandidateUpdateOneRequiredWithoutApplicationsInput
  steps: ApplicationStepUpdateManyWithoutApplicationInput
}

input ApplicationUpdateWithoutStepsDataInput {
  startDate: DateTime
  endDate: DateTime
  feedback: String
  responsible: String
  result: Result
  candidate: CandidateUpdateOneRequiredWithoutApplicationsInput
  opening: OpeningUpdateOneRequiredWithoutApplicationsInput
}

input ApplicationUpdateWithWhereUniqueWithoutCandidateInput {
  where: ApplicationWhereUniqueInput!
  data: ApplicationUpdateWithoutCandidateDataInput!
}

input ApplicationUpdateWithWhereUniqueWithoutOpeningInput {
  where: ApplicationWhereUniqueInput!
  data: ApplicationUpdateWithoutOpeningDataInput!
}

input ApplicationUpsertWithoutStepsInput {
  update: ApplicationUpdateWithoutStepsDataInput!
  create: ApplicationCreateWithoutStepsInput!
}

input ApplicationUpsertWithWhereUniqueWithoutCandidateInput {
  where: ApplicationWhereUniqueInput!
  update: ApplicationUpdateWithoutCandidateDataInput!
  create: ApplicationCreateWithoutCandidateInput!
}

input ApplicationUpsertWithWhereUniqueWithoutOpeningInput {
  where: ApplicationWhereUniqueInput!
  update: ApplicationUpdateWithoutOpeningDataInput!
  create: ApplicationCreateWithoutOpeningInput!
}

input ApplicationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  feedback: String
  feedback_not: String
  feedback_in: [String!]
  feedback_not_in: [String!]
  feedback_lt: String
  feedback_lte: String
  feedback_gt: String
  feedback_gte: String
  feedback_contains: String
  feedback_not_contains: String
  feedback_starts_with: String
  feedback_not_starts_with: String
  feedback_ends_with: String
  feedback_not_ends_with: String
  responsible: String
  responsible_not: String
  responsible_in: [String!]
  responsible_not_in: [String!]
  responsible_lt: String
  responsible_lte: String
  responsible_gt: String
  responsible_gte: String
  responsible_contains: String
  responsible_not_contains: String
  responsible_starts_with: String
  responsible_not_starts_with: String
  responsible_ends_with: String
  responsible_not_ends_with: String
  result: Result
  result_not: Result
  result_in: [Result!]
  result_not_in: [Result!]
  candidate: CandidateWhereInput
  opening: OpeningWhereInput
  steps_every: ApplicationStepWhereInput
  steps_some: ApplicationStepWhereInput
  steps_none: ApplicationStepWhereInput
  AND: [ApplicationWhereInput!]
  OR: [ApplicationWhereInput!]
  NOT: [ApplicationWhereInput!]
}

input ApplicationWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Candidate {
  id: ID!
  name: String!
  title: String!
  email: String!
  yearsOfExperience: Int
  phone: String
  skypeId: String
  salaryExpectation: Float
  cv: String
  applications(where: ApplicationWhereInput, orderBy: ApplicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Application!]
  seniority: Seniority!
  status: Status!
}

type CandidateConnection {
  pageInfo: PageInfo!
  edges: [CandidateEdge]!
  aggregate: AggregateCandidate!
}

input CandidateCreateInput {
  id: ID
  name: String!
  title: String!
  email: String!
  yearsOfExperience: Int
  phone: String
  skypeId: String
  salaryExpectation: Float
  cv: String
  applications: ApplicationCreateManyWithoutCandidateInput
  seniority: Seniority!
  status: Status!
}

input CandidateCreateOneWithoutApplicationsInput {
  create: CandidateCreateWithoutApplicationsInput
  connect: CandidateWhereUniqueInput
}

input CandidateCreateWithoutApplicationsInput {
  id: ID
  name: String!
  title: String!
  email: String!
  yearsOfExperience: Int
  phone: String
  skypeId: String
  salaryExpectation: Float
  cv: String
  seniority: Seniority!
  status: Status!
}

type CandidateEdge {
  node: Candidate!
  cursor: String!
}

enum CandidateOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
  email_ASC
  email_DESC
  yearsOfExperience_ASC
  yearsOfExperience_DESC
  phone_ASC
  phone_DESC
  skypeId_ASC
  skypeId_DESC
  salaryExpectation_ASC
  salaryExpectation_DESC
  cv_ASC
  cv_DESC
  seniority_ASC
  seniority_DESC
  status_ASC
  status_DESC
}

type CandidatePreviousValues {
  id: ID!
  name: String!
  title: String!
  email: String!
  yearsOfExperience: Int
  phone: String
  skypeId: String
  salaryExpectation: Float
  cv: String
  seniority: Seniority!
  status: Status!
}

type CandidateSubscriptionPayload {
  mutation: MutationType!
  node: Candidate
  updatedFields: [String!]
  previousValues: CandidatePreviousValues
}

input CandidateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CandidateWhereInput
  AND: [CandidateSubscriptionWhereInput!]
  OR: [CandidateSubscriptionWhereInput!]
  NOT: [CandidateSubscriptionWhereInput!]
}

input CandidateUpdateInput {
  name: String
  title: String
  email: String
  yearsOfExperience: Int
  phone: String
  skypeId: String
  salaryExpectation: Float
  cv: String
  applications: ApplicationUpdateManyWithoutCandidateInput
  seniority: Seniority
  status: Status
}

input CandidateUpdateManyMutationInput {
  name: String
  title: String
  email: String
  yearsOfExperience: Int
  phone: String
  skypeId: String
  salaryExpectation: Float
  cv: String
  seniority: Seniority
  status: Status
}

input CandidateUpdateOneRequiredWithoutApplicationsInput {
  create: CandidateCreateWithoutApplicationsInput
  update: CandidateUpdateWithoutApplicationsDataInput
  upsert: CandidateUpsertWithoutApplicationsInput
  connect: CandidateWhereUniqueInput
}

input CandidateUpdateWithoutApplicationsDataInput {
  name: String
  title: String
  email: String
  yearsOfExperience: Int
  phone: String
  skypeId: String
  salaryExpectation: Float
  cv: String
  seniority: Seniority
  status: Status
}

input CandidateUpsertWithoutApplicationsInput {
  update: CandidateUpdateWithoutApplicationsDataInput!
  create: CandidateCreateWithoutApplicationsInput!
}

input CandidateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  yearsOfExperience: Int
  yearsOfExperience_not: Int
  yearsOfExperience_in: [Int!]
  yearsOfExperience_not_in: [Int!]
  yearsOfExperience_lt: Int
  yearsOfExperience_lte: Int
  yearsOfExperience_gt: Int
  yearsOfExperience_gte: Int
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  skypeId: String
  skypeId_not: String
  skypeId_in: [String!]
  skypeId_not_in: [String!]
  skypeId_lt: String
  skypeId_lte: String
  skypeId_gt: String
  skypeId_gte: String
  skypeId_contains: String
  skypeId_not_contains: String
  skypeId_starts_with: String
  skypeId_not_starts_with: String
  skypeId_ends_with: String
  skypeId_not_ends_with: String
  salaryExpectation: Float
  salaryExpectation_not: Float
  salaryExpectation_in: [Float!]
  salaryExpectation_not_in: [Float!]
  salaryExpectation_lt: Float
  salaryExpectation_lte: Float
  salaryExpectation_gt: Float
  salaryExpectation_gte: Float
  cv: String
  cv_not: String
  cv_in: [String!]
  cv_not_in: [String!]
  cv_lt: String
  cv_lte: String
  cv_gt: String
  cv_gte: String
  cv_contains: String
  cv_not_contains: String
  cv_starts_with: String
  cv_not_starts_with: String
  cv_ends_with: String
  cv_not_ends_with: String
  applications_every: ApplicationWhereInput
  applications_some: ApplicationWhereInput
  applications_none: ApplicationWhereInput
  seniority: Seniority
  seniority_not: Seniority
  seniority_in: [Seniority!]
  seniority_not_in: [Seniority!]
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  AND: [CandidateWhereInput!]
  OR: [CandidateWhereInput!]
  NOT: [CandidateWhereInput!]
}

input CandidateWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createApplication(data: ApplicationCreateInput!): Application!
  updateApplication(data: ApplicationUpdateInput!, where: ApplicationWhereUniqueInput!): Application
  updateManyApplications(data: ApplicationUpdateManyMutationInput!, where: ApplicationWhereInput): BatchPayload!
  upsertApplication(where: ApplicationWhereUniqueInput!, create: ApplicationCreateInput!, update: ApplicationUpdateInput!): Application!
  deleteApplication(where: ApplicationWhereUniqueInput!): Application
  deleteManyApplications(where: ApplicationWhereInput): BatchPayload!
  createApplicationStep(data: ApplicationStepCreateInput!): ApplicationStep!
  updateApplicationStep(data: ApplicationStepUpdateInput!, where: ApplicationStepWhereUniqueInput!): ApplicationStep
  updateManyApplicationSteps(data: ApplicationStepUpdateManyMutationInput!, where: ApplicationStepWhereInput): BatchPayload!
  upsertApplicationStep(where: ApplicationStepWhereUniqueInput!, create: ApplicationStepCreateInput!, update: ApplicationStepUpdateInput!): ApplicationStep!
  deleteApplicationStep(where: ApplicationStepWhereUniqueInput!): ApplicationStep
  deleteManyApplicationSteps(where: ApplicationStepWhereInput): BatchPayload!
  createCandidate(data: CandidateCreateInput!): Candidate!
  updateCandidate(data: CandidateUpdateInput!, where: CandidateWhereUniqueInput!): Candidate
  updateManyCandidates(data: CandidateUpdateManyMutationInput!, where: CandidateWhereInput): BatchPayload!
  upsertCandidate(where: CandidateWhereUniqueInput!, create: CandidateCreateInput!, update: CandidateUpdateInput!): Candidate!
  deleteCandidate(where: CandidateWhereUniqueInput!): Candidate
  deleteManyCandidates(where: CandidateWhereInput): BatchPayload!
  createOpening(data: OpeningCreateInput!): Opening!
  updateOpening(data: OpeningUpdateInput!, where: OpeningWhereUniqueInput!): Opening
  updateManyOpenings(data: OpeningUpdateManyMutationInput!, where: OpeningWhereInput): BatchPayload!
  upsertOpening(where: OpeningWhereUniqueInput!, create: OpeningCreateInput!, update: OpeningUpdateInput!): Opening!
  deleteOpening(where: OpeningWhereUniqueInput!): Opening
  deleteManyOpenings(where: OpeningWhereInput): BatchPayload!
  createStep(data: StepCreateInput!): Step!
  updateStep(data: StepUpdateInput!, where: StepWhereUniqueInput!): Step
  updateManySteps(data: StepUpdateManyMutationInput!, where: StepWhereInput): BatchPayload!
  upsertStep(where: StepWhereUniqueInput!, create: StepCreateInput!, update: StepUpdateInput!): Step!
  deleteStep(where: StepWhereUniqueInput!): Step
  deleteManySteps(where: StepWhereInput): BatchPayload!
  createTemplateStep(data: TemplateStepCreateInput!): TemplateStep!
  updateTemplateStep(data: TemplateStepUpdateInput!, where: TemplateStepWhereUniqueInput!): TemplateStep
  updateManyTemplateSteps(data: TemplateStepUpdateManyMutationInput!, where: TemplateStepWhereInput): BatchPayload!
  upsertTemplateStep(where: TemplateStepWhereUniqueInput!, create: TemplateStepCreateInput!, update: TemplateStepUpdateInput!): TemplateStep!
  deleteTemplateStep(where: TemplateStepWhereUniqueInput!): TemplateStep
  deleteManyTemplateSteps(where: TemplateStepWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Opening {
  id: ID!
  jobTitle: String!
  jobDescription: String!
  company: String
  maxSalaryRange: Float
  steps(where: StepWhereInput, orderBy: StepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Step!]
  applications(where: ApplicationWhereInput, orderBy: ApplicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Application!]
  status: OpeningStatus
}

type OpeningConnection {
  pageInfo: PageInfo!
  edges: [OpeningEdge]!
  aggregate: AggregateOpening!
}

input OpeningCreateInput {
  id: ID
  jobTitle: String!
  jobDescription: String!
  company: String
  maxSalaryRange: Float
  steps: StepCreateManyInput
  applications: ApplicationCreateManyWithoutOpeningInput
  status: OpeningStatus
}

input OpeningCreateOneWithoutApplicationsInput {
  create: OpeningCreateWithoutApplicationsInput
  connect: OpeningWhereUniqueInput
}

input OpeningCreateWithoutApplicationsInput {
  id: ID
  jobTitle: String!
  jobDescription: String!
  company: String
  maxSalaryRange: Float
  steps: StepCreateManyInput
  status: OpeningStatus
}

type OpeningEdge {
  node: Opening!
  cursor: String!
}

enum OpeningOrderByInput {
  id_ASC
  id_DESC
  jobTitle_ASC
  jobTitle_DESC
  jobDescription_ASC
  jobDescription_DESC
  company_ASC
  company_DESC
  maxSalaryRange_ASC
  maxSalaryRange_DESC
  status_ASC
  status_DESC
}

type OpeningPreviousValues {
  id: ID!
  jobTitle: String!
  jobDescription: String!
  company: String
  maxSalaryRange: Float
  status: OpeningStatus
}

enum OpeningStatus {
  OPEN
  CLOSED
}

type OpeningSubscriptionPayload {
  mutation: MutationType!
  node: Opening
  updatedFields: [String!]
  previousValues: OpeningPreviousValues
}

input OpeningSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OpeningWhereInput
  AND: [OpeningSubscriptionWhereInput!]
  OR: [OpeningSubscriptionWhereInput!]
  NOT: [OpeningSubscriptionWhereInput!]
}

input OpeningUpdateInput {
  jobTitle: String
  jobDescription: String
  company: String
  maxSalaryRange: Float
  steps: StepUpdateManyInput
  applications: ApplicationUpdateManyWithoutOpeningInput
  status: OpeningStatus
}

input OpeningUpdateManyMutationInput {
  jobTitle: String
  jobDescription: String
  company: String
  maxSalaryRange: Float
  status: OpeningStatus
}

input OpeningUpdateOneRequiredWithoutApplicationsInput {
  create: OpeningCreateWithoutApplicationsInput
  update: OpeningUpdateWithoutApplicationsDataInput
  upsert: OpeningUpsertWithoutApplicationsInput
  connect: OpeningWhereUniqueInput
}

input OpeningUpdateWithoutApplicationsDataInput {
  jobTitle: String
  jobDescription: String
  company: String
  maxSalaryRange: Float
  steps: StepUpdateManyInput
  status: OpeningStatus
}

input OpeningUpsertWithoutApplicationsInput {
  update: OpeningUpdateWithoutApplicationsDataInput!
  create: OpeningCreateWithoutApplicationsInput!
}

input OpeningWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  jobTitle: String
  jobTitle_not: String
  jobTitle_in: [String!]
  jobTitle_not_in: [String!]
  jobTitle_lt: String
  jobTitle_lte: String
  jobTitle_gt: String
  jobTitle_gte: String
  jobTitle_contains: String
  jobTitle_not_contains: String
  jobTitle_starts_with: String
  jobTitle_not_starts_with: String
  jobTitle_ends_with: String
  jobTitle_not_ends_with: String
  jobDescription: String
  jobDescription_not: String
  jobDescription_in: [String!]
  jobDescription_not_in: [String!]
  jobDescription_lt: String
  jobDescription_lte: String
  jobDescription_gt: String
  jobDescription_gte: String
  jobDescription_contains: String
  jobDescription_not_contains: String
  jobDescription_starts_with: String
  jobDescription_not_starts_with: String
  jobDescription_ends_with: String
  jobDescription_not_ends_with: String
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  maxSalaryRange: Float
  maxSalaryRange_not: Float
  maxSalaryRange_in: [Float!]
  maxSalaryRange_not_in: [Float!]
  maxSalaryRange_lt: Float
  maxSalaryRange_lte: Float
  maxSalaryRange_gt: Float
  maxSalaryRange_gte: Float
  steps_every: StepWhereInput
  steps_some: StepWhereInput
  steps_none: StepWhereInput
  applications_every: ApplicationWhereInput
  applications_some: ApplicationWhereInput
  applications_none: ApplicationWhereInput
  status: OpeningStatus
  status_not: OpeningStatus
  status_in: [OpeningStatus!]
  status_not_in: [OpeningStatus!]
  AND: [OpeningWhereInput!]
  OR: [OpeningWhereInput!]
  NOT: [OpeningWhereInput!]
}

input OpeningWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  application(where: ApplicationWhereUniqueInput!): Application
  applications(where: ApplicationWhereInput, orderBy: ApplicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Application]!
  applicationsConnection(where: ApplicationWhereInput, orderBy: ApplicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ApplicationConnection!
  applicationStep(where: ApplicationStepWhereUniqueInput!): ApplicationStep
  applicationSteps(where: ApplicationStepWhereInput, orderBy: ApplicationStepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ApplicationStep]!
  applicationStepsConnection(where: ApplicationStepWhereInput, orderBy: ApplicationStepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ApplicationStepConnection!
  candidate(where: CandidateWhereUniqueInput!): Candidate
  candidates(where: CandidateWhereInput, orderBy: CandidateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Candidate]!
  candidatesConnection(where: CandidateWhereInput, orderBy: CandidateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CandidateConnection!
  opening(where: OpeningWhereUniqueInput!): Opening
  openings(where: OpeningWhereInput, orderBy: OpeningOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Opening]!
  openingsConnection(where: OpeningWhereInput, orderBy: OpeningOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OpeningConnection!
  step(where: StepWhereUniqueInput!): Step
  steps(where: StepWhereInput, orderBy: StepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Step]!
  stepsConnection(where: StepWhereInput, orderBy: StepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StepConnection!
  templateStep(where: TemplateStepWhereUniqueInput!): TemplateStep
  templateSteps(where: TemplateStepWhereInput, orderBy: TemplateStepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TemplateStep]!
  templateStepsConnection(where: TemplateStepWhereInput, orderBy: TemplateStepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TemplateStepConnection!
  node(id: ID!): Node
}

enum Result {
  BAD
  AVERAGE
  GOOD
  EXCELENT
}

enum Seniority {
  JUNIOR
  MIDDLE
  SENIOR
}

enum Status {
  AVAILABLE
  IN_PROGRESS
  HIRED
  QUIT_PROCESS
  REJECTED
}

type Step {
  id: ID!
  name: String!
  icon: String!
}

type StepConnection {
  pageInfo: PageInfo!
  edges: [StepEdge]!
  aggregate: AggregateStep!
}

input StepCreateInput {
  id: ID
  name: String!
  icon: String!
}

input StepCreateManyInput {
  create: [StepCreateInput!]
  connect: [StepWhereUniqueInput!]
}

input StepCreateOneInput {
  create: StepCreateInput
  connect: StepWhereUniqueInput
}

type StepEdge {
  node: Step!
  cursor: String!
}

enum StepOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  icon_ASC
  icon_DESC
}

type StepPreviousValues {
  id: ID!
  name: String!
  icon: String!
}

input StepScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  AND: [StepScalarWhereInput!]
  OR: [StepScalarWhereInput!]
  NOT: [StepScalarWhereInput!]
}

type StepSubscriptionPayload {
  mutation: MutationType!
  node: Step
  updatedFields: [String!]
  previousValues: StepPreviousValues
}

input StepSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StepWhereInput
  AND: [StepSubscriptionWhereInput!]
  OR: [StepSubscriptionWhereInput!]
  NOT: [StepSubscriptionWhereInput!]
}

input StepUpdateDataInput {
  name: String
  icon: String
}

input StepUpdateInput {
  name: String
  icon: String
}

input StepUpdateManyDataInput {
  name: String
  icon: String
}

input StepUpdateManyInput {
  create: [StepCreateInput!]
  update: [StepUpdateWithWhereUniqueNestedInput!]
  upsert: [StepUpsertWithWhereUniqueNestedInput!]
  delete: [StepWhereUniqueInput!]
  connect: [StepWhereUniqueInput!]
  set: [StepWhereUniqueInput!]
  disconnect: [StepWhereUniqueInput!]
  deleteMany: [StepScalarWhereInput!]
  updateMany: [StepUpdateManyWithWhereNestedInput!]
}

input StepUpdateManyMutationInput {
  name: String
  icon: String
}

input StepUpdateManyWithWhereNestedInput {
  where: StepScalarWhereInput!
  data: StepUpdateManyDataInput!
}

input StepUpdateOneRequiredInput {
  create: StepCreateInput
  update: StepUpdateDataInput
  upsert: StepUpsertNestedInput
  connect: StepWhereUniqueInput
}

input StepUpdateWithWhereUniqueNestedInput {
  where: StepWhereUniqueInput!
  data: StepUpdateDataInput!
}

input StepUpsertNestedInput {
  update: StepUpdateDataInput!
  create: StepCreateInput!
}

input StepUpsertWithWhereUniqueNestedInput {
  where: StepWhereUniqueInput!
  update: StepUpdateDataInput!
  create: StepCreateInput!
}

input StepWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  AND: [StepWhereInput!]
  OR: [StepWhereInput!]
  NOT: [StepWhereInput!]
}

input StepWhereUniqueInput {
  id: ID
}

type Subscription {
  application(where: ApplicationSubscriptionWhereInput): ApplicationSubscriptionPayload
  applicationStep(where: ApplicationStepSubscriptionWhereInput): ApplicationStepSubscriptionPayload
  candidate(where: CandidateSubscriptionWhereInput): CandidateSubscriptionPayload
  opening(where: OpeningSubscriptionWhereInput): OpeningSubscriptionPayload
  step(where: StepSubscriptionWhereInput): StepSubscriptionPayload
  templateStep(where: TemplateStepSubscriptionWhereInput): TemplateStepSubscriptionPayload
}

type TemplateStep {
  steps(where: StepWhereInput, orderBy: StepOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Step!]
  name: String
  id: ID!
}

type TemplateStepConnection {
  pageInfo: PageInfo!
  edges: [TemplateStepEdge]!
  aggregate: AggregateTemplateStep!
}

input TemplateStepCreateInput {
  steps: StepCreateManyInput
  name: String
  id: ID
}

type TemplateStepEdge {
  node: TemplateStep!
  cursor: String!
}

enum TemplateStepOrderByInput {
  name_ASC
  name_DESC
  id_ASC
  id_DESC
}

type TemplateStepPreviousValues {
  name: String
  id: ID!
}

type TemplateStepSubscriptionPayload {
  mutation: MutationType!
  node: TemplateStep
  updatedFields: [String!]
  previousValues: TemplateStepPreviousValues
}

input TemplateStepSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TemplateStepWhereInput
  AND: [TemplateStepSubscriptionWhereInput!]
  OR: [TemplateStepSubscriptionWhereInput!]
  NOT: [TemplateStepSubscriptionWhereInput!]
}

input TemplateStepUpdateInput {
  steps: StepUpdateManyInput
  name: String
}

input TemplateStepUpdateManyMutationInput {
  name: String
}

input TemplateStepWhereInput {
  steps_every: StepWhereInput
  steps_some: StepWhereInput
  steps_none: StepWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [TemplateStepWhereInput!]
  OR: [TemplateStepWhereInput!]
  NOT: [TemplateStepWhereInput!]
}

input TemplateStepWhereUniqueInput {
  id: ID
}
`
      }
    